#pragma config(Motor,  port1, null,    tmotorNormal, openLoop)
#pragma config(Motor,  port2, null,     tmotorNormal, openLoop)
#pragma config(Motor,  port3, null,     tmotorNormal, openLoop)
#pragma config(Motor,  port4, null,      tmotorNormal, openLoop)
#pragma config(Motor,  port5, null,    tmotorNormal, openLoop)
#pragma config(Motor,  port6, null,		tmotorNormal, openLoop)
#pragma config(Motor,  port7,null,   tmotorNormal, openLoop)
#pragma config(Motor,  port8, nll, tmotorNormal, openLoop)
#pragma config(Motor,  port9, null  tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(5)
#pragma userControlDuration(999999999)


#include "Vex_Competition_Includes.c"


//#pragma DebuggerWindows("debugStream")
/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++
Mecanum Drive - Basic
- This program allows you to remotely control a robot with mecanum wheels.
- The left joystick Y-axis controls the robot's forward and backward movement.
- The left joystick X-axis controls the robot's left and right movement.
- The right joystick X-axis controls the robot's rotation.


[I/O Port]          [Name]              [Type]                [Description]

--------------------------------------------------------------------------------------------------*/

void pre_auton(){
}


task autonomous(){

}


task usercontrol(){
	clearDebugStream();
	while(1 == 1){
		motor[frontRight] = (vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4])/1.5;
		motor[backRight] =  (vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[frontLeft] = (vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[backLeft] =  (vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4])/1.5;
	}
}
/*

							Field
y	¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
	¦															 ¦
0	+------------------------------+
	0															x


Dimensions are in centimeteres and also INPUTS

*/
bool moving;
//TODO FIX MOVIND
void moveX(int speed){
	while(1 == 1){
		motor[frontRight] = (vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4])/1.5;
		motor[backRight] =  (vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[frontLeft] = (vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[backLeft] =  (vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4])/1.5;
	}
}

void moveY(int speed){
	while(1 == 1){
		motor[frontRight] = (vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4])/1.5;
		motor[backRight] =  (vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[frontLeft] = (vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[backLeft] =  (vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4])/1.5;
	}
}

void moveXY(int xSpeed, int ySpeed){
	while(1 == 1){
		motor[frontRight] = (vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4])/1.5;
		motor[backRight] =  (vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[frontLeft] = (vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4])/1.5;
		motor[backLeft] =  (vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4])/1.5;
	}
}

void setMoving(bool state){
	moving = state;
}

void openClaw(){//WILL OPEN CLAW A SMIDGE EVERYTIME CALLED
	//TODO MOTORS for CLAW
}

void closeClaw(){//WILL CLOSE CLAW A SMIDGE EVERYTIME CALLED
	//TODO MOTIORS FOR CLAW
}

void moveX(int xDisp){//Takes in the amount of x displaced, will displace the current x displacement by amound inputted, forexample x currently
											//at 70 from the leftinput(30) will move 70 to the right
	bool running = true;
	int beginX = SONAR SENSOR XVALUE;
	int targetX = beginX + xDisp;
	while(running){
		//TODO move(left or right) in which way to achieve target value
		if(current XvaluSoNAR - targetX <= 0)running = false;
	}

}

void moveY(int yDisp){//Takes in the amount of y displaced, will displace the current y displacement by amound inputted, forexample y currently
											//at 30 from the bottom input(70) will move 70 up
	bool running = true;
	int beginY = SONAR SENSOR yVALUE;
	int targetX = beginY + yDisp;
	while(running){
		//TODO move(up or down) in which way to achieve target value
		if(current XvaluSoNAR - targetY <= 0)running = false;
	}

}

void moveXY(int xDisp, int yDisp){//Will displace both x and y at the same time
	bool running = true;
	int beginX = SONAR SENSOR XVALUE;
	int targetX = beginX + xDisp;
	int beginY = SONAR SENSOR yVALUE;
	int targetX = beginY + yDisp;
	while(running){
		//TODO move(left or right) in which way to achieve target value
		if(current XvaluSoNAR - targetX <= 0&&current XvaluSoNAR - targetY <= 0)running = false;
	}
}

void moveToX(int xDisp){//Move the bot to the niputed x displacement
	bool running = true;
	while(running){
		//TODO move(left or right) in which way to achieve target value
		if(current XvaluSoNAR - xDisp)running = false;
	}
}
void moveToY(int YDisp){//Move the bot to the niputed y displacement
	bool running = true;
	while(running){
		//TODO move(left or right) in which way to achieve target value
		if(current YvaluSoNAR - yDisp)running = false;
	}
}

void moveToXY(int xDisp, int yDisp){//Will move to both xDisp and yDisp at the same time
	bool running = true;

	while(running){
		//TODO move(left or right) in which way to achieve target value
		if(current XvaluSoNAR - xDisp <= 0&&current XvaluSoNAR - yDisp <= 0)running = false;
	}
}

void align90{//Create a triangle to align the bot with rotate to have it perpendicular to the walls

}

void rotate(int degrees){

}
